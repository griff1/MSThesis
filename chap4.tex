\chapter{Reliability in SCDTs}

\section{Cached Nack Reliability}
Just like in traditional Internet services, IoT applications have a variety of
reliability constraints.  We propose that in a SCDT, the reliability should be
constructed using negative acknowledgments (``nacks") from children.  Previous
research has already shown the negative acknowledgment scheme to be superior to
regular acknowledgments in traditional network-level multicast trees
\cite{SRM, RFC3208}; we argue that this principle extends to SCDTs.
Unlike these previous schemes, SCDTs utilize caching at intermediate nodes.  We
argue that drafting intermediate routers as caches will improve scalability (by
reducing the amount of traffic that must flow to the root) and improve partition
tolerance (since retransmission could still occur even if the path to the root
is lost).  We call this scheme Cached Nack Reliability (CNR).

The SCDT forwards data unreliably to improve latency, but caches the data it
forwards at each intermediate nodes.  A simple nacking scheme could use a similar method to that employed in TCP \cite{RFC0793}: by examining an incrementally increasing sequence number associated with the SCDT included with every packet.  Gaps observed in the sequence numbers of received packets indicate what data to nack.  Periodic heartbeats sent by child nodes and acknowledged by parents keep sequence numbers updated even when data isn't frequently published.  However, we argue for a more complex method: including a byte offset and packet length in the header of each packet.  This method supports refragmentation of packets at intermediate points in the network.

Leaves can determine their reliability constraints for themselves, and send a
nack for the missing data to their parent.  If there is a cache hit, the data is
retransmitted; if there is a miss, the nack is forwarded to the leaf's
grandparent and so on, ultimately creating a hierarchy of caches.  A slightly
more sophisticated scheme could use timers with exponential backoff to reduce
unnecessary and redundant nacking \cite{SRM, RFC3208}.  Since we are
arguing for a reliable system and the scheme presented so far relies on caches,
there must ultimately be one or more places in the network where data is durably
stored when caches all miss; 
see~\autoref{durability-replication} for more
details.

Such a scheme provides a best of both worlds solution, minimizing latency while
supporting packet retransmission.  It breaks the
traditional reliable vs unreliable (generally TCP vs UDP) trade off developers
must choose between.  By putting the impetus to nack packets on the leaf, rather
than being completely reliable or unreliable, a leaf node could set a level of
unreliability.  For instance, a leaf node could choose to nack just enough
packets to maintain a particular record reception rate.


\section{Evaluation}

We've simulated the impact of CNR using ns-3 \cite{ns3}, a discrete-event network simulator. Rather than cherry-pick topologies that, we've used BRITE \cite{brite} to generate Internet-like topologies and draw our results over the average performance of many different runs over many different topologies. We "install" our software on a random subset of these nodes to simulate an incrementally-deployed, Internet spanning network of subscribers. We believe this approach gives us superior results, which are both realistic to a real-world deployment and not dependent on a specific topology. 

We utilize the same naive multicast tree building protocol used as a strawman in~\autoref{scdt-eval} to build the underlying multicast tree for our tests. That is, the tree is constructed in five steps: 

\begin{enumerate}  
	\item A joining node contacts the root and requests to join the tree. 
	\item The root pings the joining node to determine its round trip latency. 
	\item If the latency is substantially shorter than its existing children (or if the root has fewer children than MAX\_FANOUT), the root adds the joining node as a direct child. If not, the root sends back a list of its children.
	\item The joining node pings all of the children to determine which has the lowest latency.
	\item The joining node repeats the process with the closest (determined by round trip time) child. The process is repeated until the joining node finds a parent that will accept it.
\end{enumerate}

We build reliability into this tree in two different ways. The first is by creating TCP links between every parent and child, essentially creating a series of point-to-point TCP links. The second way is using CNR. Our results are predicated on comparing these two methods. 

Using point-to-point TCP presents a number of issues in actual deployments. One is the risk of bottlenecking the entire tree due to one bad link, where a router's buffer becomes full and must drop incoming packets because it cannot push out data to one of its children fast enough. Another issue is the high computational cost of setting up TCP links, which is non-ideal if the tree is continuously shifting and re-optimizing. While we don't advocate using point-to-point TCP in multicast trees, it is a useful contrast point because it represent a fairly direct comparison to reliability in the unicast space.

\subsection{Results}