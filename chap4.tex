\chapter{Reliability in SCDTs}

\section{Cached Nack Reliability}
Just like in traditional Internet services, IoT applications have a variety of
reliability constraints.  We propose that in a SCDT, the reliability should be
constructed using negative acknowledgments (``nacks") from children.  Previous
research has already shown the negative acknowledgment scheme to be superior to
regular acknowledgments in traditional network-level multicast trees
\cite{SRM, RFC3208}; we argue that this principle extends to SCDTs.
Unlike these previous schemes, SCDTs utilize caching at intermediate nodes.  We
argue that drafting intermediate routers as caches will improve scalability (by
reducing the amount of traffic that must flow to the root) and improve partition
tolerance (since retransmission could still occur even if the path to the root
is lost).  We call this scheme Cached Nack Reliability (CNR).

The SCDT forwards data unreliably to improve latency, but caches the data it
forwards at each intermediate node.  A traditional simple nacking scheme could use a similar method to that employed in TCP \cite{RFC0793}: by examining an incrementally increasing sequence number associated with the SCDT included with every packet.  Gaps observed in the sequence numbers of received packets indicate what data to nack.  Periodic heartbeats sent by child nodes and acknowledged by parents keep sequence numbers updated even when data isn't frequently published.  However, we argue for a more complex method: including a byte offset and packet length in the header of each packet.  This method supports refragmentation of packets at intermediate points in the network.

Leaves can determine their reliability constraints for themselves, and send a
nack for the missing data to their parent.  If there is a cache hit, the data is
retransmitted; if there is a miss, the nack is forwarded to the leaf's
grandparent and so on, ultimately creating a hierarchy of caches.  A slightly
more sophisticated scheme could use timers with exponential backoff to reduce
unnecessary and redundant nacking \cite{SRM, RFC3208}.  Since we are
arguing for a reliable system and the scheme presented so far relies on caches,
there must ultimately be one or more places in the network where data is durably
stored when caches all miss; 
see~\autoref{durability-replication} for more
details.

Such a scheme provides a best of both worlds solution, minimizing latency while
supporting packet retransmission.  It breaks the
traditional reliable vs unreliable (generally TCP vs UDP) trade off developers
must choose between.  By putting the impetus to nack packets on the leaf, rather
than being completely reliable or unreliable, a leaf node could set a level of
unreliability.  For instance, a leaf node could choose to nack just enough
packets to maintain a particular record reception rate.


\section{Evaluation}

